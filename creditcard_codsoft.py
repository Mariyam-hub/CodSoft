# -*- coding: utf-8 -*-
"""Creditcard.CodSoft

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cVYlp8xlXgEODB8lT9LFDVejYnCDnGYw
"""

import pandas as pd

# Load the dataset
dataset_path = '/content/creditcard.csv'
credit_card_data = pd.read_csv(dataset_path)

# Display the first few rows of the dataset
print(credit_card_data.head())

# Basic information about the dataset
print(credit_card_data.info())

# Check class imbalance
print("\nClass distribution:\n", credit_card_data['Class'].value_counts())

from sklearn.preprocessing import StandardScaler

# Separate features and target
X = credit_card_data.drop('Class', axis=1)
y = credit_card_data['Class']

# Normalize the numerical features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Verify scaled data
print("\nScaled Features Sample:\n", X_scaled[:5])

from imblearn.over_sampling import SMOTE
from collections import Counter

# Handle class imbalance using SMOTE
smote = SMOTE(random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_scaled, y)

# Check the new class distribution
print("\nClass distribution after SMOTE:\n", Counter(y_resampled))

from sklearn.model_selection import train_test_split

# Split the resampled data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X_resampled, y_resampled, test_size=0.2, random_state=42)

print("Training set size:", X_train.shape)
print("Testing set size:", X_test.shape)

from sklearn.linear_model import LogisticRegression

# Train Logistic Regression model
logreg_model = LogisticRegression(random_state=42, max_iter=200)
logreg_model.fit(X_train, y_train)

# Predict and evaluate
y_pred = logreg_model.predict(X_test)

X_train_sample = X_train[:5000]  # Use the first 5000 samples for training
y_train_sample = y_train[:5000]

rf_model = RandomForestClassifier(n_estimators=50, random_state=42)
rf_model.fit(X_train_sample, y_train_sample)

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, classification_report, confusion_matrix

# Make predictions
y_pred = rf_model.predict(X_test)

# Evaluation metrics
accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)

print("Accuracy:", accuracy)
print("Precision:", precision)
print("Recall:", recall)
print("F1 Score:", f1)
print("\nClassification Report:\n", classification_report(y_test, y_pred))

# Confusion Matrix
conf_matrix = confusion_matrix(y_test, y_pred)
print("\nConfusion Matrix:\n", conf_matrix)

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['Genuine', 'Fraudulent'], yticklabels=['Genuine', 'Fraudulent'])
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.show()

# Before resampling
plt.figure(figsize=(8, 6))
credit_card_data['Class'].value_counts().plot(kind='bar', color=['lightcoral', 'skyblue'])
plt.title('Class Distribution Before Resampling')
plt.xlabel('Class (0 = Genuine, 1 = Fraudulent)')
plt.ylabel('Count')
plt.show()

# After resampling
plt.figure(figsize=(8, 6))
pd.Series(y_resampled).value_counts().plot(kind='bar', color=['lightcoral', 'skyblue'])
plt.title('Class Distribution After Resampling')
plt.xlabel('Class (0 = Genuine, 1 = Fraudulent)')
plt.ylabel('Count')
plt.show()

# Feature importance visualization
feature_importances = rf_model.feature_importances_
features = credit_card_data.drop('Class', axis=1).columns

plt.figure(figsize=(10, 6))
sns.barplot(x=feature_importances, y=features, palette="viridis")
plt.title('Feature Importances')
plt.xlabel('Importance Score')
plt.ylabel('Features')
plt.show()

# Pie chart for fraudulent vs. genuine transactions
fraud_counts = credit_card_data['Class'].value_counts()
labels = ['Genuine', 'Fraudulent']
colors = ['lightgreen', 'red']

plt.figure(figsize=(8, 8))
plt.pie(fraud_counts, labels=labels, autopct='%1.1f%%', startangle=90, colors=colors, explode=[0, 0.1])
plt.title('Fraudulent vs. Genuine Transactions')
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle
plt.show()

# Bar chart for fraudulent vs. genuine transactions
plt.figure(figsize=(8, 6))
sns.countplot(x='Class', data=credit_card_data, palette='coolwarm')
plt.title('Fraudulent vs. Genuine Transactions')
plt.xlabel('Class (0 = Genuine, 1 = Fraudulent)')
plt.ylabel('Count')
plt.xticks([0, 1], ['Genuine', 'Fraudulent'])
plt.show()

# Box plot for transaction amount by class
plt.figure(figsize=(10, 6))
sns.boxplot(x='Class', y='Amount', data=credit_card_data, palette='Set2')
plt.title('Transaction Amounts: Genuine vs. Fraudulent')
plt.xlabel('Class (0 = Genuine, 1 = Fraudulent)')
plt.ylabel('Transaction Amount')
plt.xticks([0, 1], ['Genuine', 'Fraudulent'])
plt.show()

# Heatmap of correlations
plt.figure(figsize=(15, 10))
correlation_matrix = credit_card_data.corr()
sns.heatmap(correlation_matrix, cmap='coolwarm', annot=False, cbar=True)
plt.title('Correlation Matrix')
plt.show()

# Distribution of transaction amounts
plt.figure(figsize=(10, 6))
sns.histplot(data=credit_card_data, x='Amount', hue='Class', kde=True, palette='husl', bins=50)
plt.title('Distribution of Transaction Amounts')
plt.xlabel('Transaction Amount')
plt.ylabel('Frequency')
plt.legend(['Genuine', 'Fraudulent'])
plt.show()

# Scatter plot for Time vs. Amount
plt.figure(figsize=(12, 8))
sns.scatterplot(x='Time', y='Amount', hue='Class', data=credit_card_data, palette={0: 'green', 1: 'red'}, alpha=0.6)
plt.title('Transaction Time vs. Amount')
plt.xlabel('Time')
plt.ylabel('Transaction Amount')
plt.legend(title='Class', labels=['Genuine (0)', 'Fraudulent (1)'])
plt.show()

# KDE plot for transaction amounts
plt.figure(figsize=(10, 6))
sns.kdeplot(data=credit_card_data[credit_card_data['Class'] == 0]['Amount'], fill=True, label='Genuine', color='green', alpha=0.5)
sns.kdeplot(data=credit_card_data[credit_card_data['Class'] == 1]['Amount'], fill=True, label='Fraudulent', color='red', alpha=0.5)
plt.title('Density Plot of Transaction Amounts')
plt.xlabel('Transaction Amount')
plt.ylabel('Density')
plt.legend()
plt.show()